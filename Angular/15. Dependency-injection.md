# Dependency Injection (DI) in Angular

## ⭐ What is Dependency Injection?

**Dependency Injection (DI)** is a design pattern where a class receives the objects it depends on (**dependencies**) from outside rather than creating them itself.

---

# ⭐ Why Use DI in Angular?

- Promotes **loose coupling**  
- Makes code **easier to test**  
- Encourages **reusability**  
- Allows Angular to manage service **lifecycle**  
- Ensures consistent **singleton** behavior

---

# ⭐ `@Injectable()` Decorator

Marks a class as available for Angular’s Dependency Injection system.

```ts
@Injectable({
  providedIn: 'root',
})
export class MyService {
  constructor() {}
}
```

### Meaning of `providedIn: 'root'`:

- Angular auto-registers this service in the **root injector**
- A **single global instance** is created (singleton)
- You can inject it anywhere using the constructor
- No need to manually add it to `providers`

---

# ⭐ Why `new Service()` is Wrong for Injectable Classes

### ❌ Avoid:  
```ts
const auth = new AuthenticationService();  
```

Because Angular cannot inject required dependencies.

Example:

```ts
@Injectable({ providedIn: 'root' })
export class AuthenticationService {
  constructor(private http: HttpClient) {}
}
```

If you use `new AuthenticationService()`:

- `http` does **not** get injected  
- `this.http` becomes **undefined**  
- Any method like `this.http.post()` will crash

**Error:**
```
Cannot read 'post' of undefined
```

---

# ⭐ When You *Must* Use DI

If your class depends on another class:

```ts
export class A {
  constructor(private b: B) {}
}
```

Then you **must** use Angular DI.

---

# ⭐ When You *Can* Use `new` Keyword

Only when the class has **no dependencies** and is **not meant to be a service**.

Example:

```ts
export class MathHelper {
  add(a: number, b: number) { return a + b; }
}
```

Both are valid:

```ts
const m = new MathHelper(); // ✔ OK
```

OR:

```ts
constructor(private math: MathHelper) {} // ✔ OK
```

---

# ⭐ IMPORTANT  
### If you add `@Injectable({ providedIn: 'root' })`:

- The class becomes an Angular **service**
- Angular creates ONE singleton instance
- You must access it using **constructor DI**
- Never use `new ClassName()` with Injectable

---

# ⭐ Angular Services Are Not Simple Classes

They often depend on Angular features like:

- HttpClient  
- Interceptors  
- Observables  
- Router  

Only Angular DI can create them correctly.

---

# ⭐ Summary Table

| Scenario | Use DI? | Use `new`? | Notes |
|----------|---------|------------|-------|
| Class has dependencies | ✔ YES | ❌ NO | Required |
| Decorated with `@Injectable` | ✔ YES | ❌ NO | Angular-managed service |
| Pure helper class (no dependencies) | Optional | ✔ YES | Safe |
| Shared state / singleton needed | ✔ YES | ❌ NO | Best practice |

---

# ⭐ Final Rules (Easy to Remember)

- If a class uses `@Injectable()` → always use DI  
- If a class has dependencies → use DI  
- If class is a helper → `new` is fine  
- Never use `new` with Injectable classes  
- `providedIn: 'root'` = global singleton  
